import os
import subprocess
import sys

import sumolib

from envs.anon_env import AnonEnv
from envs.anon_env import Intersection
import traci
import traci.constants as tc
import numpy as np

from misc.utils import get_vehicle_list

os.environ['SUMO_HOME'] = '/usr/share/sumo'
sys.path.append(os.path.join(os.environ["SUMO_HOME"], "tools"))


class Intersection(Intersection):
    def __init__(self, inter_name, dic_traffic_env_conf, eng):
        self.dic_phase_strs = self.create_phase_str(dic_traffic_env_conf)
        super().__init__(inter_name, dic_traffic_env_conf, eng)

    def set_tl_phase(self, inter_name, phase_index):
        if phase_index != self.yellow_phase_index:
            phase_str = self.dic_phase_strs[self.current_phase_index]
        else:
            phase_str = ''
            for i in self.dic_phase_strs[self.current_phase_index]:
                if i != 'G':
                    phase_str += 'r'
                else:
                    phase_str += 'y'
        self.eng.trafficlight.setRedYellowGreenState(
            self.inter_name, phase_str)

    def create_phase_str(self, dic_traffic_env_conf):
        list_phase_index = dic_traffic_env_conf["LANE_PHASE_INFO"]["phase"]
        yellow_phase_index = dic_traffic_env_conf["LANE_PHASE_INFO"][
            "yellow_phase"]
        phase_str = {}
        phase_length = len(list_phase_index + [yellow_phase_index])
        for idx in list_phase_index + [yellow_phase_index]:
            each_phase = ''
            for i in range(phase_length):
                if idx == i:
                    each_phase += 'G'
                else:
                    each_phase += 'r'
            phase_str[idx] = each_phase
        phase_str[yellow_phase_index] = 'r' * phase_length
        return phase_str

    def update_current_measurements(self):
        if self.current_phase_index == self.previous_phase_index:
            self.current_phase_duration += 1
        else:
            self.current_phase_duration = 1
        self.dic_lane_vehicle_current_step = self.eng.vehicle.getIDList()
        self.dic_lane_vehicle_waiting_current_step = \
            self.eng.get_lane_waiting_vehicle_count()
        if self.dic_traffic_env_conf["ENV_DEBUG"]:
            self.dic_vehicle_speed_current_step = self.eng.get_vehicle_speed()
            self.dic_vehicle_distance_current_step = \
                self.eng.get_vehicle_distance()

        vehicle_now = get_vehicle_list(self.dic_lane_vehicle_current_step)
        vehicle_pre = get_vehicle_list(self.dic_lane_vehicle_previous_step)
        list_vehicle_new_arrive = list(set(vehicle_now) - set(vehicle_pre))
        # TODO this maybe the true value. the function below maybe
        #  think the vehicle leave entering lane is leaving the env
        list_vehicle_new_left = list(set(vehicle_pre) - set(vehicle_now))

        list_vehicle_new_left_entering_lane_by_lane = \
            self._update_leave_entering_approach_vehicle()
        list_vehicle_new_left_entering_lane = []
        for l in list_vehicle_new_left_entering_lane_by_lane:
            list_vehicle_new_left_entering_lane += l
        # update vehicle arrive and left time
        self._update_arrive_time(list_vehicle_new_arrive)
        # self._update_left_time(list_vehicle_new_left)
        self._update_left_time(list_vehicle_new_left_entering_lane)
        self._update_feature()

    def get_current_time(self):
        return traci.simulation.getCurrentTime() / 1000


class SumoEnv(AnonEnv):
    def __init__(self, dic_path, dic_traffic_env_conf):
        super().__init__(dic_path, dic_traffic_env_conf)

    def reset(self):
        file_sumocfg = self.dic_path["PATH_TO_ROADNET_FILE"
                       ].split(".net.xml")[0] + ".sumocfg"
        interval = str(self.dic_traffic_env_conf["INTERVAL"])
        port = str(self.dic_traffic_env_conf["PORT"])
        if self.dic_traffic_env_conf['IF_GUI']:
            self.sumo_cmd = ["sumo-gui", '-c', file_sumocfg, "--remote-port",
                             port, "--no-warnings", "--no-step-log", "--random",
                             "--step-length", interval
                             ]
        else:
            self.sumo_cmd = ["sumo", '-c', file_sumocfg, "--remote-port",
                             port, "--no-warnings", "--no-step-log", "--random",
                             "--step-length", interval]
        print("start sumo")

        fp = open(os.devnull)
        self.sumo_process = \
            subprocess.Popen(self.sumo_cmd, stdout=fp, stderr=None)
        fp.close()

        self.eng = traci.connect(port)

        self.eng.start(self.sumo_cmd)
        self.reset_prepare()
        state = self.get_state()
        return state

    def reset_prepare(self):
        self.list_intersection = []
        self.list_inter_log = dict()
        self.list_lanes = []

        for inter_name in sorted(self.lane_phase_infos.keys()):
            intersection = Intersection(
                inter_name, self.dic_traffic_env_conf, self.eng)
            self.list_intersection.append(intersection)
            self.list_inter_log[inter_name] = []

        roadnet = sumolib.net.readNet(self.dic_path["PATH_TO_ROADNET_FILE"])

        LIST_LANE_VARIABLES_TO_SUB = [
            "LAST_STEP_VEHICLE_NUMBER",
            "LAST_STEP_VEHICLE_ID_LIST",
            "LAST_STEP_VEHICLE_HALTING_NUMBER",
            "VAR_WAITING_TIME",
        ]
        for edge in roadnet.getEdges():
            for lane in edge.getLanes():
                self.eng.lane.subscribe(lane,
                                        [getattr(tc, var) for var in
                                         LIST_LANE_VARIABLES_TO_SUB])
        self.list_lanes = np.unique(self.list_lanes).tolist()

        for inter in self.list_intersection:
            inter.update_current_measurements()

    def step(self, action):
        list_action_in_sec = [action]
        list_action_in_sec_display = [action]
        for i in range(self.dic_traffic_env_conf["MIN_ACTION_TIME"] - 1):
            list_action_in_sec.append(np.copy(action).tolist())
            list_action_in_sec_display.append(
                np.full_like(action, fill_value=-1).tolist())
        average_reward = 0
        next_state, reward, done = None, None, None
        for i in range(self.dic_traffic_env_conf["MIN_ACTION_TIME"]):
            action_in_sec = list_action_in_sec[i]
            action_in_sec_display = list_action_in_sec_display[i]
            instant_time = self.eng.simulation.getCurrentTime() / 1000
            before_action_feature = self.get_feature()

            self._inner_step(action_in_sec)
            reward = self.get_reward()
            average_reward = (average_reward * i + reward[0]) / (i + 1)

            self.log(cur_time=instant_time,
                     before_action_feature=before_action_feature,
                     action=action_in_sec_display)
            next_state = self.get_state()
            if self.dic_traffic_env_conf["DONE_ENABLE"]:
                done = self._check_episode_done(next_state)
            else:
                done = False
            print('.', end='')
            if done:
                print("||done||")
        return next_state, reward, done, [average_reward]


if __name__ == '__main__':
    os.chdir('../')
    # Out of date. refresh please.
    print('sumo env test start...')
    print('test finished..')
